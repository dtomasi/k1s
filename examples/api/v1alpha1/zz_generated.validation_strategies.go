//go:build !ignore_autogenerated

// Code generated by cli-gen. DO NOT EDIT.

package v1alpha1

import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/google/cel-go/cel"
	exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	"google.golang.org/protobuf/proto"
	"k8s.io/apimachinery/pkg/runtime"

	"github.com/dtomasi/k1s/core/pkg/validation"
)

// Pre-compiled CEL expressions for optimal runtime performance
var (
	celValidationf84666ceExpr = []byte{0x10, 0x02, 0x32, 0x19, 0x12, 0x03, 0x5f, 0x3e, 0x5f, 0x1a, 0x0a, 0x10, 0x01, 0x22, 0x06, 0x0a,
		0x04, 0x73, 0x65, 0x6c, 0x66, 0x1a, 0x06, 0x10, 0x03, 0x1a, 0x02, 0x18, 0x00}
	celValidationf84666ceProgram cel.Program
	celValidation65246ba3Expr    = []byte{0x10, 0x02, 0x32, 0x1a, 0x12, 0x04, 0x5f, 0x3e, 0x3d, 0x5f, 0x1a, 0x0a, 0x10, 0x01, 0x22, 0x06,
		0x0a, 0x04, 0x73, 0x65, 0x6c, 0x66, 0x1a, 0x06, 0x10, 0x03, 0x1a, 0x02, 0x18, 0x00}
	celValidation65246ba3Program cel.Program
	celValidation592ccbb0Expr    = []byte{0x10, 0x02, 0x32, 0x1b, 0x12, 0x04, 0x5f, 0x3c, 0x3d, 0x5f, 0x1a, 0x0a, 0x10, 0x01, 0x22, 0x06,
		0x0a, 0x04, 0x73, 0x65, 0x6c, 0x66, 0x1a, 0x07, 0x10, 0x03, 0x1a, 0x03, 0x18, 0x90, 0x4e}
	celValidation592ccbb0Program cel.Program
)

// CEL environment for deserializing compiled expressions
var celEnv *cel.Env

func init() {
	var err error
	celEnv, err = cel.NewEnv(
		cel.Variable("self", cel.AnyType),
		cel.Variable("oldSelf", cel.AnyType),
	)
	if err != nil {
		panic(fmt.Sprintf("failed to create CEL environment: %v", err))
	}

	// Deserialize pre-compiled CEL expressions
	{
		var expr exprpb.Expr
		if err := proto.Unmarshal(celValidationf84666ceExpr, &expr); err != nil {
			panic(fmt.Sprintf("failed to unmarshal CEL expression celValidationf84666ce: %v", err))
		}
		ast := cel.ParsedExprToAst(&exprpb.ParsedExpr{Expr: &expr})
		celValidationf84666ceProgram, err = celEnv.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program celValidationf84666ce: %v", err))
		}
	}
	{
		var expr exprpb.Expr
		if err := proto.Unmarshal(celValidation65246ba3Expr, &expr); err != nil {
			panic(fmt.Sprintf("failed to unmarshal CEL expression celValidation65246ba3: %v", err))
		}
		ast := cel.ParsedExprToAst(&exprpb.ParsedExpr{Expr: &expr})
		celValidation65246ba3Program, err = celEnv.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program celValidation65246ba3: %v", err))
		}
	}
	{
		var expr exprpb.Expr
		if err := proto.Unmarshal(celValidation592ccbb0Expr, &expr); err != nil {
			panic(fmt.Sprintf("failed to unmarshal CEL expression celValidation592ccbb0: %v", err))
		}
		ast := cel.ParsedExprToAst(&exprpb.ParsedExpr{Expr: &expr})
		celValidation592ccbb0Program, err = celEnv.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program celValidation592ccbb0: %v", err))
		}
	}
}

// GetValidationStrategy returns the validation strategy for a given kind
func GetValidationStrategy(kind string) validation.ValidationStrategy {
	strategy, ok := validationStrategies[kind]
	if !ok {
		return &NoOpValidationStrategy{}
	}
	return strategy
}

// NoOpValidationStrategy is a no-op validation strategy
type NoOpValidationStrategy struct{}

func (s *NoOpValidationStrategy) Execute(ctx context.Context, obj runtime.Object) []validation.ValidationError {
	return nil
}

func (s *NoOpValidationStrategy) SupportsType(obj runtime.Object) bool {
	return true
}

var validationStrategies = map[string]validation.ValidationStrategy{
	"Category": &CategoryValidationStrategy{},
	"Item":     &ItemValidationStrategy{},
}

// Compile-time interface assertions
var _ validation.ValidationStrategy = (*CategoryValidationStrategy)(nil)
var _ validation.ValidationStrategy = (*ItemValidationStrategy)(nil)

// CategoryValidationStrategy validates Category objects
type CategoryValidationStrategy struct{}

func (s *CategoryValidationStrategy) Execute(ctx context.Context, obj runtime.Object) []validation.ValidationError {
	var errors []validation.ValidationError

	// Use reflection to access the object fields
	val := reflect.ValueOf(obj)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	if val.Kind() != reflect.Struct {
		return []validation.ValidationError{
			{
				Field:   "root",
				Message: "expected struct object",
			},
		}
	}

	typ := val.Type()
	// Validate field: Description
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Description"); specFoundField {
				fieldValue = specField.FieldByName("Description")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Description"); statusFoundField {
					fieldValue = statusField.FieldByName("Description")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Description"); rootFound {
				fieldValue = val.FieldByName("Description")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// MaxLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) > 200 {
					errors = append(errors, validation.ValidationError{
						Field:   "Description",
						Message: fmt.Sprintf("field must be at most 200 characters long, got %d", len(str)),
					})
				}
			}
		}
	}
	// Validate field: Name
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Name"); specFoundField {
				fieldValue = specField.FieldByName("Name")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Name"); statusFoundField {
					fieldValue = statusField.FieldByName("Name")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Name"); rootFound {
				fieldValue = val.FieldByName("Name")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Required validation
			if isFieldEmpty(fieldInterface) {
				errors = append(errors, validation.ValidationError{
					Field:   "Name",
					Message: "field is required but empty",
				})
			}
			// MinLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) < 1 {
					errors = append(errors, validation.ValidationError{
						Field:   "Name",
						Message: fmt.Sprintf("field must be at least 1 characters long, got %d", len(str)),
					})
				}
			}
			// MaxLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) > 50 {
					errors = append(errors, validation.ValidationError{
						Field:   "Name",
						Message: fmt.Sprintf("field must be at most 50 characters long, got %d", len(str)),
					})
				}
			}
		}
	}

	return errors
}

func (s *CategoryValidationStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "Category" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*v1alpha1.Category"
}

// ItemValidationStrategy validates Item objects
type ItemValidationStrategy struct{}

func (s *ItemValidationStrategy) Execute(ctx context.Context, obj runtime.Object) []validation.ValidationError {
	var errors []validation.ValidationError

	// Use reflection to access the object fields
	val := reflect.ValueOf(obj)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	if val.Kind() != reflect.Struct {
		return []validation.ValidationError{
			{
				Field:   "root",
				Message: "expected struct object",
			},
		}
	}

	typ := val.Type()
	// Validate field: Category
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Category"); specFoundField {
				fieldValue = specField.FieldByName("Category")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Category"); statusFoundField {
					fieldValue = statusField.FieldByName("Category")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Category"); rootFound {
				fieldValue = val.FieldByName("Category")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Required validation
			if isFieldEmpty(fieldInterface) {
				errors = append(errors, validation.ValidationError{
					Field:   "Category",
					Message: "field is required but empty",
				})
			}
			// MinLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) < 1 {
					errors = append(errors, validation.ValidationError{
						Field:   "Category",
						Message: fmt.Sprintf("field must be at least 1 characters long, got %d", len(str)),
					})
				}
			}
		}
	}
	// Validate field: Description
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Description"); specFoundField {
				fieldValue = specField.FieldByName("Description")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Description"); statusFoundField {
					fieldValue = statusField.FieldByName("Description")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Description"); rootFound {
				fieldValue = val.FieldByName("Description")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// MaxLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) > 500 {
					errors = append(errors, validation.ValidationError{
						Field:   "Description",
						Message: fmt.Sprintf("field must be at most 500 characters long, got %d", len(str)),
					})
				}
			}
		}
	}
	// Validate field: Name
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Name"); specFoundField {
				fieldValue = specField.FieldByName("Name")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Name"); statusFoundField {
					fieldValue = statusField.FieldByName("Name")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Name"); rootFound {
				fieldValue = val.FieldByName("Name")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Required validation
			if isFieldEmpty(fieldInterface) {
				errors = append(errors, validation.ValidationError{
					Field:   "Name",
					Message: "field is required but empty",
				})
			}
			// MinLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) < 1 {
					errors = append(errors, validation.ValidationError{
						Field:   "Name",
						Message: fmt.Sprintf("field must be at least 1 characters long, got %d", len(str)),
					})
				}
			}
			// MaxLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) > 100 {
					errors = append(errors, validation.ValidationError{
						Field:   "Name",
						Message: fmt.Sprintf("field must be at most 100 characters long, got %d", len(str)),
					})
				}
			}
		}
	}
	// Validate field: Price
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Price"); specFoundField {
				fieldValue = specField.FieldByName("Price")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Price"); statusFoundField {
					fieldValue = statusField.FieldByName("Price")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Price"); rootFound {
				fieldValue = val.FieldByName("Price")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Pre-compiled CEL validation: self > 0
			{
				// Find the corresponding compiled CEL program
				result, _, err := celValidationf84666ceProgram.Eval(map[string]interface{}{
					"self": fieldInterface,
				})
				if err != nil {
					errors = append(errors, validation.ValidationError{
						Type:    validation.ValidationErrorTypeInvalid,
						Field:   "Price",
						Message: fmt.Sprintf("CEL evaluation error: %v", err),
						Rule:    "self > 0",
					})
				} else if result != nil {
					if boolResult, ok := result.Value().(bool); ok && !boolResult {
						message := "price must be positive"
						if message == "" {
							message = fmt.Sprintf("CEL expression failed: self > 0")
						}
						errors = append(errors, validation.ValidationError{
							Type:    validation.ValidationErrorTypeInvalid,
							Field:   "Price",
							Message: message,
							Rule:    "self > 0",
						})
					}
				}
			}
			// Minimum validation
			if num := getNumericValue(fieldInterface); num != nil {
				if *num < 0 {
					errors = append(errors, validation.ValidationError{
						Field:   "Price",
						Message: fmt.Sprintf("field must be at least 0, got %v", *num),
					})
				}
			}
		}
	}
	// Validate field: Quantity
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Quantity"); specFoundField {
				fieldValue = specField.FieldByName("Quantity")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Quantity"); statusFoundField {
					fieldValue = statusField.FieldByName("Quantity")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Quantity"); rootFound {
				fieldValue = val.FieldByName("Quantity")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Pre-compiled CEL validation: self >= 0
			{
				// Find the corresponding compiled CEL program
				result, _, err := celValidation65246ba3Program.Eval(map[string]interface{}{
					"self": fieldInterface,
				})
				if err != nil {
					errors = append(errors, validation.ValidationError{
						Type:    validation.ValidationErrorTypeInvalid,
						Field:   "Quantity",
						Message: fmt.Sprintf("CEL evaluation error: %v", err),
						Rule:    "self >= 0",
					})
				} else if result != nil {
					if boolResult, ok := result.Value().(bool); ok && !boolResult {
						message := "quantity must be non-negative"
						if message == "" {
							message = fmt.Sprintf("CEL expression failed: self >= 0")
						}
						errors = append(errors, validation.ValidationError{
							Type:    validation.ValidationErrorTypeInvalid,
							Field:   "Quantity",
							Message: message,
							Rule:    "self >= 0",
						})
					}
				}
			}
			// Pre-compiled CEL validation: self <= 10000
			{
				// Find the corresponding compiled CEL program
				result, _, err := celValidation592ccbb0Program.Eval(map[string]interface{}{
					"self": fieldInterface,
				})
				if err != nil {
					errors = append(errors, validation.ValidationError{
						Type:    validation.ValidationErrorTypeInvalid,
						Field:   "Quantity",
						Message: fmt.Sprintf("CEL evaluation error: %v", err),
						Rule:    "self <= 10000",
					})
				} else if result != nil {
					if boolResult, ok := result.Value().(bool); ok && !boolResult {
						message := "quantity cannot exceed 10000"
						if message == "" {
							message = fmt.Sprintf("CEL expression failed: self <= 10000")
						}
						errors = append(errors, validation.ValidationError{
							Type:    validation.ValidationErrorTypeInvalid,
							Field:   "Quantity",
							Message: message,
							Rule:    "self <= 10000",
						})
					}
				}
			}
			// Minimum validation
			if num := getNumericValue(fieldInterface); num != nil {
				if *num < 0 {
					errors = append(errors, validation.ValidationError{
						Field:   "Quantity",
						Message: fmt.Sprintf("field must be at least 0, got %v", *num),
					})
				}
			}
		}
	}
	// Validate field: Status
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool

		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("Status"); specFoundField {
				fieldValue = specField.FieldByName("Status")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("Status"); statusFoundField {
					fieldValue = statusField.FieldByName("Status")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("Status"); rootFound {
				fieldValue = val.FieldByName("Status")
				found = true
			}
		}

		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			// Enum validation
			if str, ok := fieldInterface.(string); ok {
				validValues := []string{"Available", "Reserved", "Sold", "Discontinued"}
				isValid := false
				for _, valid := range validValues {
					if str == valid {
						isValid = true
						break
					}
				}
				if !isValid {
					errors = append(errors, validation.ValidationError{
						Field:   "Status",
						Message: fmt.Sprintf("field must be one of [%s], got %s", strings.Join(validValues, ", "), str),
					})
				}
			}
		}
	}

	return errors
}

func (s *ItemValidationStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "Item" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*v1alpha1.Item"
}

// Helper functions for validation

// isFieldEmpty checks if a field value is considered empty
func isFieldEmpty(value interface{}) bool {
	if value == nil {
		return true
	}

	v := reflect.ValueOf(value)
	switch v.Kind() {
	case reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return false // bool values are never considered empty for required validation
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0.0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
		return v.Len() == 0
	case reflect.Struct:
		// For structs, check if it's a zero value
		return v.Interface() == reflect.Zero(v.Type()).Interface()
	default:
		return false
	}
}

// getNumericValue extracts numeric value from interface{} for numeric validations
func getNumericValue(value interface{}) *float64 {
	if value == nil {
		return nil
	}

	v := reflect.ValueOf(value)

	// Handle pointers by dereferencing them
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return nil
		}
		v = v.Elem()
	}

	var result float64

	switch v.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		result = float64(v.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		result = float64(v.Uint())
	case reflect.Float32, reflect.Float64:
		result = v.Float()
	case reflect.String:
		// Try to parse string as number
		if f, err := strconv.ParseFloat(v.String(), 64); err == nil {
			result = f
		} else {
			return nil
		}
	default:
		return nil
	}

	return &result
}

// matchesPattern validates string against regex pattern
func matchesPattern(value string, pattern string) bool {
	regex, err := regexp.Compile(pattern)
	if err != nil {
		// If pattern is invalid, consider it as not matching
		return false
	}
	return regex.MatchString(value)
}
