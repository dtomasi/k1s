//go:build !ignore_autogenerated

// Code generated by cli-gen. DO NOT EDIT.

package v1alpha1

import (
	"context"
	"reflect"

	"k8s.io/apimachinery/pkg/runtime"

	"github.com/dtomasi/k1s/core/defaulting"
)

// GetDefaultingStrategy returns the defaulting strategy for a given kind
func GetDefaultingStrategy(kind string) defaulting.DefaultingStrategy {
	strategy, ok := defaultingStrategies[kind]
	if !ok {
		return &NoOpDefaultingStrategy{}
	}
	return strategy
}

// NoOpDefaultingStrategy is a no-op defaulting strategy
type NoOpDefaultingStrategy struct{}

func (s *NoOpDefaultingStrategy) Apply(ctx context.Context, obj runtime.Object) error {
	return nil
}

func (s *NoOpDefaultingStrategy) SupportsType(obj runtime.Object) bool {
	return true
}

var defaultingStrategies = map[string]defaulting.DefaultingStrategy{
	"Category": &CategoryDefaultingStrategy{},
	"Item":     &ItemDefaultingStrategy{},
}

// Compile-time interface assertions
var _ defaulting.DefaultingStrategy = (*CategoryDefaultingStrategy)(nil)
var _ defaulting.DefaultingStrategy = (*ItemDefaultingStrategy)(nil)

// CategoryDefaultingStrategy applies defaults to Category objects
type CategoryDefaultingStrategy struct{}

func (s *CategoryDefaultingStrategy) Apply(ctx context.Context, obj runtime.Object) error {
	rv := reflect.ValueOf(obj)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}

	if rv.Kind() != reflect.Struct {
		return nil // Skip non-struct objects
	}

	// Apply defaults to Spec field if it exists
	specField := rv.FieldByName("Spec")
	if specField.IsValid() && specField.Kind() == reflect.Struct && specField.CanSet() {
		s.applySpecDefaults(specField)
	}

	// Apply defaults to Status field if it exists
	statusField := rv.FieldByName("Status")
	if statusField.IsValid() && statusField.Kind() == reflect.Struct && statusField.CanSet() {
		s.applyStatusDefaults(statusField)
	}

	return nil
}

func (s *CategoryDefaultingStrategy) applySpecDefaults(specValue reflect.Value) {
	// Apply default for ItemCount
	if field := specValue.FieldByName("ItemCount"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			// String field
			field.SetString("0")
		}
	}
	// Apply default for SubCategoryCount
	if field := specValue.FieldByName("SubCategoryCount"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			// String field
			field.SetString("0")
		}
	}
}

func (s *CategoryDefaultingStrategy) applyStatusDefaults(statusValue reflect.Value) {
}

func (s *CategoryDefaultingStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "Category" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*v1alpha1.Category"
}

// ItemDefaultingStrategy applies defaults to Item objects
type ItemDefaultingStrategy struct{}

func (s *ItemDefaultingStrategy) Apply(ctx context.Context, obj runtime.Object) error {
	rv := reflect.ValueOf(obj)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}

	if rv.Kind() != reflect.Struct {
		return nil // Skip non-struct objects
	}

	// Apply defaults to Spec field if it exists
	specField := rv.FieldByName("Spec")
	if specField.IsValid() && specField.Kind() == reflect.Struct && specField.CanSet() {
		s.applySpecDefaults(specField)
	}

	// Apply defaults to Status field if it exists
	statusField := rv.FieldByName("Status")
	if statusField.IsValid() && statusField.Kind() == reflect.Struct && statusField.CanSet() {
		s.applyStatusDefaults(statusField)
	}

	return nil
}

func (s *ItemDefaultingStrategy) applySpecDefaults(specValue reflect.Value) {
	// Apply default for Quantity
	if field := specValue.FieldByName("Quantity"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			// Integer field
			field.SetInt(1)
		}
	}
}

func (s *ItemDefaultingStrategy) applyStatusDefaults(statusValue reflect.Value) {
	// Apply default for Status
	if field := statusValue.FieldByName("Status"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			field.SetString("Available")
		}
	}
}

func (s *ItemDefaultingStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "Item" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*v1alpha1.Item"
}

// Helper function to check if a value is zero
func isZeroValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	}
	return false
}
