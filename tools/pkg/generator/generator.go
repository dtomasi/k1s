// Package generator provides code generation functionality for k1s instrumentation
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/dtomasi/k1s/tools/pkg/extractor"
)

// Generator handles code generation from extracted resource information
type Generator struct {
	outputDir string
}

// NewGenerator creates a new code generator
func NewGenerator(outputDir string) *Generator {
	return &Generator{
		outputDir: outputDir,
	}
}

// Generate creates k1s instrumentation code from resource information
func (g *Generator) Generate(resources []*extractor.ResourceInfo) error {
	if len(resources) == 0 {
		return fmt.Errorf("no resources to generate")
	}

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.outputDir, 0750); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate resource metadata
	if err := g.generateResourceMetadata(resources); err != nil {
		return fmt.Errorf("failed to generate resource metadata: %w", err)
	}

	// Generate validation strategies
	if err := g.generateValidationStrategies(resources); err != nil {
		return fmt.Errorf("failed to generate validation strategies: %w", err)
	}

	// Generate print columns
	if err := g.generatePrintColumns(resources); err != nil {
		return fmt.Errorf("failed to generate print columns: %w", err)
	}

	return nil
}

// generateResourceMetadata generates resource metadata lookup functions
func (g *Generator) generateResourceMetadata(resources []*extractor.ResourceInfo) error {
	tmpl := `// Code generated by cli-gen. DO NOT EDIT.

package generated

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// ResourceMetadata contains metadata about a resource type
type ResourceMetadata struct {
	Kind       string
	Group      string
	Version    string
	Plural     string
	Singular   string
	ShortNames []string
	Scope      string
	HasStatus  bool
}

// GetResourceMetadata returns metadata for a given resource kind
func GetResourceMetadata(kind string) (*ResourceMetadata, bool) {
	metadata, ok := resourceMetadataMap[kind]
	return metadata, ok
}

// GetResourceByPlural returns metadata for a resource by its plural name
func GetResourceByPlural(plural string) (*ResourceMetadata, bool) {
	for _, meta := range resourceMetadataMap {
		if meta.Plural == plural {
			return meta, true
		}
	}
	return nil, false
}

// GetResourceByShortName returns metadata for a resource by its short name
func GetResourceByShortName(shortName string) (*ResourceMetadata, bool) {
	for _, meta := range resourceMetadataMap {
		for _, sn := range meta.ShortNames {
			if sn == shortName {
				return meta, true
			}
		}
	}
	return nil, false
}

// GetAllResourceMetadata returns all known resource metadata
func GetAllResourceMetadata() map[string]*ResourceMetadata {
	result := make(map[string]*ResourceMetadata)
	for k, v := range resourceMetadataMap {
		result[k] = v
	}
	return result
}

var resourceMetadataMap = map[string]*ResourceMetadata{
{{- range .Resources }}
	"{{ .Kind }}": {
		Kind:       "{{ .Kind }}",
		Group:      "{{ .Group }}",
		Version:    "{{ .Version }}",
		Plural:     "{{ or .Plural (pluralize .Kind) }}",
		Singular:   "{{ or .Singular (toLower .Kind) }}",
		ShortNames: []string{ {{- range .ShortNames }}"{{ . }}", {{- end }} },
		Scope:      "{{ or .Scope "Namespaced" }}",
		HasStatus:  {{ .HasStatus }},
	},
{{- end }}
}

// GetGroupVersionResource returns the GVR for a given kind
func GetGroupVersionResource(kind string) (*schema.GroupVersionResource, bool) {
	meta, ok := GetResourceMetadata(kind)
	if !ok {
		return nil, false
	}

	gvr := &schema.GroupVersionResource{
		Group:    meta.Group,
		Version:  meta.Version,
		Resource: meta.Plural,
	}
	return gvr, true
}

// GetGroupVersionKind returns the GVK for a given kind  
func GetGroupVersionKind(kind string) (*schema.GroupVersionKind, bool) {
	meta, ok := GetResourceMetadata(kind)
	if !ok {
		return nil, false
	}

	gvk := &schema.GroupVersionKind{
		Group:   meta.Group,
		Version: meta.Version,
		Kind:    meta.Kind,
	}
	return gvk, true
}
`

	return g.executeTemplate("resource_metadata.go", tmpl, map[string]interface{}{
		"Resources": resources,
	})
}

// generateValidationStrategies generates validation strategy functions
func (g *Generator) generateValidationStrategies(resources []*extractor.ResourceInfo) error {
	// For now, generate a simple validation interface without complex templates
	tmpl := `// Code generated by cli-gen. DO NOT EDIT.

package generated

import (
	"fmt"
	"reflect"
	"strings"
)

// ValidationStrategy validates a resource object
type ValidationStrategy interface {
	Validate(obj interface{}) []ValidationError
}

// ValidationError represents a validation error
type ValidationError struct {
	Field   string
	Message string
}

// GetValidationStrategy returns the validation strategy for a given kind
func GetValidationStrategy(kind string) ValidationStrategy {
	strategy, ok := validationStrategies[kind]
	if !ok {
		return &NoOpValidationStrategy{}
	}
	return strategy
}

// NoOpValidationStrategy is a no-op validation strategy
type NoOpValidationStrategy struct{}

func (s *NoOpValidationStrategy) Validate(obj interface{}) []ValidationError {
	return nil
}

var validationStrategies = map[string]ValidationStrategy{
{{- range .Resources }}
{{- if .Validations }}
	"{{ .Kind }}": &{{ .Kind }}ValidationStrategy{},
{{- end }}
{{- end }}
}

{{- range .Resources }}
{{- if .Validations }}

// {{ .Kind }}ValidationStrategy validates {{ .Kind }} objects  
type {{ .Kind }}ValidationStrategy struct{}

func (s *{{ .Kind }}ValidationStrategy) Validate(obj interface{}) []ValidationError {
	// TODO: Implement detailed validation based on kubebuilder markers
	// For now, return empty validation
	return nil
}
{{- end }}
{{- end }}
`

	return g.executeTemplate("validation_strategies.go", tmpl, map[string]interface{}{
		"Resources": resources,
	})
}

// generatePrintColumns generates print column definitions
func (g *Generator) generatePrintColumns(resources []*extractor.ResourceInfo) error {
	tmpl := `// Code generated by cli-gen. DO NOT EDIT.

package generated

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// PrintColumn represents a column definition for table output
type PrintColumn struct {
	Name        string
	Type        string
	JSONPath    string
	Description string
	Priority    int32
}

// GetPrintColumns returns the print columns for a given resource kind
func GetPrintColumns(kind string) []PrintColumn {
	columns, ok := printColumnsMap[kind]
	if !ok {
		return []PrintColumn{}
	}
	return columns
}

// GetTableColumnDefinitions returns Kubernetes table column definitions
func GetTableColumnDefinitions(kind string) []metav1.TableColumnDefinition {
	columns := GetPrintColumns(kind)
	definitions := make([]metav1.TableColumnDefinition, len(columns))
	
	for i, col := range columns {
		definitions[i] = metav1.TableColumnDefinition{
			Name:        col.Name,
			Type:        col.Type,
			Description: col.Description,
			Priority:    col.Priority,
			Format:      "",
		}
	}
	
	return definitions
}

var printColumnsMap = map[string][]PrintColumn{
{{- range .Resources }}
{{- if .PrintColumns }}
	"{{ .Kind }}": {
		{{- range .PrintColumns }}
		{
			Name:        "{{ .Name }}",
			Type:        "{{ .Type }}",
			JSONPath:    "{{ .JSONPath }}",
			Description: "{{ .Description }}",
			Priority:    {{ .Priority }},
		},
		{{- end }}
	},
{{- end }}
{{- end }}
}
`

	return g.executeTemplate("print_columns.go", tmpl, map[string]interface{}{
		"Resources": resources,
	})
}

// executeTemplate executes a template and writes the output to a file
func (g *Generator) executeTemplate(filename, templateStr string, data interface{}) error {
	// Create custom functions for templates
	funcMap := template.FuncMap{
		"pluralize": func(s string) string {
			// Simple pluralization - can be enhanced
			lower := strings.ToLower(s)
			if strings.HasSuffix(lower, "y") {
				return lower[:len(lower)-1] + "ies"
			}
			if strings.HasSuffix(lower, "s") {
				return lower + "es"
			}
			return lower + "s"
		},
		"split":   strings.Split,
		"toLower": strings.ToLower,
		"or": func(a, b string) string {
			if a != "" {
				return a
			}
			return b
		},
	}

	tmpl, err := template.New(filename).Funcs(funcMap).Parse(templateStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated Go code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		fmt.Printf("Warning: failed to format generated code: %v\n", err)
		formatted = buf.Bytes()
	}

	outputPath := filepath.Join(g.outputDir, filename)
	if err := os.WriteFile(outputPath, formatted, 0600); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)
	return nil
}
