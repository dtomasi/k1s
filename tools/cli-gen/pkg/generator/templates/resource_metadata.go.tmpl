//go:build !ignore_autogenerated

// Code generated by cli-gen. DO NOT EDIT.

package {{.PackageName}}

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/dtomasi/k1s/core/registry"
)

// GroupVersionKind constants for resources
var (
{{- range .Resources }}
	// {{.Kind}}GroupVersionKind is the GVK for {{.Kind}} resources
	{{.Kind}}GroupVersionKind = schema.GroupVersionKind{
		Group:   "{{.Group}}",
		Version: "{{.Version}}",
		Kind:    "{{.Kind}}",
	}
{{- end }}
)

// ResourceMetadata contains metadata about a resource type
type ResourceMetadata struct {
	Group      string
	Version    string
	Config     registry.ResourceConfig
}

// GetResourceMetadata returns metadata for a given resource kind
func GetResourceMetadata(kind string) (*ResourceMetadata, bool) {
	metadata, ok := resourceMetadataMap[kind]
	return metadata, ok
}

// GetResourceByPlural returns metadata for a resource by its plural name
func GetResourceByPlural(plural string) (*ResourceMetadata, bool) {
	for _, meta := range resourceMetadataMap {
		if meta.Config.Plural == plural {
			return meta, true
		}
	}
	return nil, false
}

// GetResourceByShortName returns metadata for a resource by its short name
func GetResourceByShortName(shortName string) (*ResourceMetadata, bool) {
	for _, meta := range resourceMetadataMap {
		for _, sn := range meta.Config.ShortNames {
			if sn == shortName {
				return meta, true
			}
		}
	}
	return nil, false
}

// GetAllResourceMetadata returns all known resource metadata
func GetAllResourceMetadata() map[string]*ResourceMetadata {
	result := make(map[string]*ResourceMetadata)
	for k, v := range resourceMetadataMap {
		result[k] = v
	}
	return result
}

var resourceMetadataMap = map[string]*ResourceMetadata{
{{- range .Resources }}
	"{{ .Kind }}": {
		Group:   "{{ .Group }}",
		Version: "{{ .Version }}",
		Config: registry.ResourceConfig{
			Kind:        "{{ .Kind }}",
			ListKind:    "{{ .Kind }}List",
			Singular:    "{{ or .Singular (toLower .Kind) }}",
			Plural:      "{{ or .Plural (pluralize .Kind) }}",
			Namespaced:  {{ eq (or .Scope "Namespaced") "Namespaced" }},
			ShortNames:  []string{ {{- range .ShortNames }}"{{ . }}", {{- end }} },
			{{- if .PrintColumns }}
			PrintColumns: []metav1.TableColumnDefinition{
				{{- range .PrintColumns }}
				{
					Name:        "{{ .Name }}",
					Type:        "{{ .Type }}",
					Format:      "",
					Description: "{{ .Description }}",
					Priority:    int32({{ .Priority }}),
				},
				{{- end }}
			},
			{{- end }}
			Categories:  []string{}, // Categories can be added later if needed
			Description: "{{ .Kind }} resource",
		},
	},
{{- end }}
}

// GetGroupVersionResource returns the GVR for a given kind
func GetGroupVersionResource(kind string) (*schema.GroupVersionResource, bool) {
	meta, ok := GetResourceMetadata(kind)
	if !ok {
		return nil, false
	}

	gvr := &schema.GroupVersionResource{
		Group:    meta.Group,
		Version:  meta.Version,
		Resource: meta.Config.Plural,
	}
	return gvr, true
}

// GetGroupVersionKind returns the GVK for a given kind
func GetGroupVersionKind(kind string) (*schema.GroupVersionKind, bool) {
	meta, ok := GetResourceMetadata(kind)
	if !ok {
		return nil, false
	}

	gvk := &schema.GroupVersionKind{
		Group:   meta.Group,
		Version: meta.Version,
		Kind:    meta.Config.Kind,
	}
	return gvk, true
}

// GetAllGroupVersionKinds returns all GroupVersionKinds for this package
func GetAllGroupVersionKinds() []schema.GroupVersionKind {
	return []schema.GroupVersionKind{
{{- range .Resources }}
		{{.Kind}}GroupVersionKind,
{{- end }}
	}
}

// GetGVKFromKind returns the GroupVersionKind for a given Kind string
func GetGVKFromKind(kind string) (schema.GroupVersionKind, bool) {
	switch kind {
{{- range .Resources }}
	case "{{.Kind}}":
		return {{.Kind}}GroupVersionKind, true
{{- end }}
	default:
		return schema.GroupVersionKind{}, false
	}
}

// RegisterAllResources registers all generated resources with the provided registry
func RegisterAllResources(reg registry.Registry) error {
{{- range .Resources }}
	// Register {{ .Kind }}
	{
		meta := resourceMetadataMap["{{ .Kind }}"]
		gvr := schema.GroupVersionResource{
			Group:    meta.Group,
			Version:  meta.Version,
			Resource: meta.Config.Plural,
		}

		if err := reg.RegisterResource(gvr, meta.Config); err != nil {
			return err
		}
	}
{{- end }}
	return nil
}