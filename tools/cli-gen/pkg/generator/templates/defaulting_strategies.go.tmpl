//go:build !ignore_autogenerated

// Code generated by cli-gen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"reflect"

	"k8s.io/apimachinery/pkg/runtime"

	"github.com/dtomasi/k1s/core/defaulting"
)

// GetDefaultingStrategy returns the defaulting strategy for a given kind
func GetDefaultingStrategy(kind string) defaulting.DefaultingStrategy {
	strategy, ok := defaultingStrategies[kind]
	if !ok {
		return &NoOpDefaultingStrategy{}
	}
	return strategy
}

// NoOpDefaultingStrategy is a no-op defaulting strategy
type NoOpDefaultingStrategy struct{}

func (s *NoOpDefaultingStrategy) Apply(ctx context.Context, obj runtime.Object) error {
	return nil
}

func (s *NoOpDefaultingStrategy) SupportsType(obj runtime.Object) bool {
	return true
}

var defaultingStrategies = map[string]defaulting.DefaultingStrategy{
{{- range .Resources }}
{{- if .Defaults }}
	"{{ .Kind }}": &{{ .Kind }}DefaultingStrategy{},
{{- end }}
{{- end }}
}

// Compile-time interface assertions
{{- range .Resources }}
{{- if .Defaults }}
var _ defaulting.DefaultingStrategy = (*{{ .Kind }}DefaultingStrategy)(nil)
{{- end }}
{{- end }}

{{- range .Resources }}
{{- if .Defaults }}

// {{ .Kind }}DefaultingStrategy applies defaults to {{ .Kind }} objects
type {{ .Kind }}DefaultingStrategy struct{}

func (s *{{ .Kind }}DefaultingStrategy) Apply(ctx context.Context, obj runtime.Object) error {
	rv := reflect.ValueOf(obj)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}

	if rv.Kind() != reflect.Struct {
		return nil // Skip non-struct objects
	}

	// Apply defaults to Spec field if it exists
	specField := rv.FieldByName("Spec")
	if specField.IsValid() && specField.Kind() == reflect.Struct && specField.CanSet() {
		s.applySpecDefaults(specField)
	}

	// Apply defaults to Status field if it exists
	statusField := rv.FieldByName("Status")
	if statusField.IsValid() && statusField.Kind() == reflect.Struct && statusField.CanSet() {
		s.applyStatusDefaults(statusField)
	}

	return nil
}

func (s *{{ .Kind }}DefaultingStrategy) applySpecDefaults(specValue reflect.Value) {
	{{- range $fieldName, $defaultValue := .Defaults }}
	{{- if ne $fieldName "Status" }}
	// Apply default for {{ $fieldName }}
	if field := specValue.FieldByName("{{ $fieldName }}"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			{{- if eq $fieldName "Quantity" }}
			// Integer field
			field.SetInt({{ $defaultValue }})
			{{- else }}
			// String field
			field.SetString("{{ $defaultValue }}")
			{{- end }}
		}
	}
	{{- end }}
	{{- end }}
}

func (s *{{ .Kind }}DefaultingStrategy) applyStatusDefaults(statusValue reflect.Value) {
	{{- range $fieldName, $defaultValue := .Defaults }}
	{{- if eq $fieldName "Status" }}
	// Apply default for Status
	if field := statusValue.FieldByName("Status"); field.IsValid() && field.CanSet() {
		if isZeroValue(field) {
			field.SetString("{{ $defaultValue }}")
		}
	}
	{{- end }}
	{{- end }}
}

func (s *{{ .Kind }}DefaultingStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "{{ .Kind }}" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*{{ $.PackageName }}.{{ .Kind }}"
}
{{- end }}
{{- end }}

// Helper function to check if a value is zero
func isZeroValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	}
	return false
}