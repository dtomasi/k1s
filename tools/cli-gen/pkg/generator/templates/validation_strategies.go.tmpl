//go:build !ignore_autogenerated

// Code generated by cli-gen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/google/cel-go/cel"
	"google.golang.org/protobuf/proto"
	exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	"k8s.io/apimachinery/pkg/runtime"
	
	"github.com/dtomasi/k1s/core/pkg/validation"
)

{{- if .CompiledCELExpressions }}
// Pre-compiled CEL expressions for optimal runtime performance
var (
{{- range .CompiledCELExpressions }}
	{{ .GetExprVarName }} = {{ .FormatSerializedBytes }}
	{{ .GetProgramVarName }} cel.Program
{{- end }}
)

// CEL environment for deserializing compiled expressions
var celEnv *cel.Env

func init() {
	var err error
	celEnv, err = cel.NewEnv(
		cel.Variable("self", cel.AnyType),
		cel.Variable("oldSelf", cel.AnyType),
	)
	if err != nil {
		panic(fmt.Sprintf("failed to create CEL environment: %v", err))
	}
	
	// Deserialize pre-compiled CEL expressions
{{- range .CompiledCELExpressions }}
	{
		var expr exprpb.Expr
		if err := proto.Unmarshal({{ .GetExprVarName }}, &expr); err != nil {
			panic(fmt.Sprintf("failed to unmarshal CEL expression {{ .VarName }}: %v", err))
		}
		ast := cel.ParsedExprToAst(&exprpb.ParsedExpr{Expr: &expr})
		{{ .GetProgramVarName }}, err = celEnv.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program {{ .VarName }}: %v", err))
		}
	}
{{- end }}
}
{{- end }}

// GetValidationStrategy returns the validation strategy for a given kind
func GetValidationStrategy(kind string) validation.ValidationStrategy {
	strategy, ok := validationStrategies[kind]
	if !ok {
		return &NoOpValidationStrategy{}
	}
	return strategy
}

// NoOpValidationStrategy is a no-op validation strategy
type NoOpValidationStrategy struct{}

func (s *NoOpValidationStrategy) Execute(ctx context.Context, obj runtime.Object) []validation.ValidationError {
	return nil
}

func (s *NoOpValidationStrategy) SupportsType(obj runtime.Object) bool {
	return true
}

var validationStrategies = map[string]validation.ValidationStrategy{
{{- range .Resources }}
{{- if .Validations }}
	"{{ .Kind }}": &{{ .Kind }}ValidationStrategy{},
{{- end }}
{{- end }}
}

// Compile-time interface assertions
{{- range .Resources }}
{{- if .Validations }}
var _ validation.ValidationStrategy = (*{{ .Kind }}ValidationStrategy)(nil)
{{- end }}
{{- end }}

{{- range .Resources }}
{{- if .Validations }}

// {{ .Kind }}ValidationStrategy validates {{ .Kind }} objects  
type {{ .Kind }}ValidationStrategy struct{}

func (s *{{ .Kind }}ValidationStrategy) Execute(ctx context.Context, obj runtime.Object) []validation.ValidationError {
	var errors []validation.ValidationError
	
	// Use reflection to access the object fields
	val := reflect.ValueOf(obj)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	
	if val.Kind() != reflect.Struct {
		return []validation.ValidationError{
			{
				Field:   "root",
				Message: "expected struct object",
			},
		}
	}
	
	typ := val.Type()
	
	{{- range $fieldName, $validations := .Validations }}
	// Validate field: {{ $fieldName }}
	{
		var fieldValue reflect.Value
		var fieldInterface interface{}
		var found bool
		
		// Try to find field in Spec substruct first (since that's where business logic fields are)
		if specField := val.FieldByName("Spec"); specField.IsValid() && specField.Kind() == reflect.Struct {
			if _, specFoundField := specField.Type().FieldByName("{{ $fieldName }}"); specFoundField {
				fieldValue = specField.FieldByName("{{ $fieldName }}")
				found = true
			}
		}
		// Try to find field in Status substruct if not found in Spec
		if !found {
			if statusField := val.FieldByName("Status"); statusField.IsValid() && statusField.Kind() == reflect.Struct {
				if _, statusFoundField := statusField.Type().FieldByName("{{ $fieldName }}"); statusFoundField {
					fieldValue = statusField.FieldByName("{{ $fieldName }}")
					found = true
				}
			}
		}
		// Try to find field in root struct as last resort
		if !found {
			if _, rootFound := typ.FieldByName("{{ $fieldName }}"); rootFound {
				fieldValue = val.FieldByName("{{ $fieldName }}")
				found = true
			}
		}
		
		if found && fieldValue.IsValid() && fieldValue.CanInterface() {
			fieldInterface = fieldValue.Interface()
			
			{{- range $validations }}
			{{- if eq .Type "CEL" }}
			// Pre-compiled CEL validation: {{ .Rule }}
			{
				// Find the corresponding compiled CEL program
				{{- $currentFieldName := $fieldName }}
				{{- $currentRule := .Rule }}
				{{- range $.CompiledCELExpressions }}
				{{- if and (eq .FieldName $currentFieldName) (eq .OriginalExpression $currentRule) }}
				result, _, err := {{ .GetProgramVarName }}.Eval(map[string]interface{}{
					"self": fieldInterface,
				})
				if err != nil {
					errors = append(errors, validation.ValidationError{
						Type:    validation.ValidationErrorTypeInvalid,
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("CEL evaluation error: %v", err),
						Rule:    "{{ .OriginalExpression }}",
					})
				} else if result != nil {
					if boolResult, ok := result.Value().(bool); ok && !boolResult {
						message := "{{ .Message }}"
						if message == "" {
							message = fmt.Sprintf("CEL expression failed: {{ .OriginalExpression }}")
						}
						errors = append(errors, validation.ValidationError{
							Type:    validation.ValidationErrorTypeInvalid,
							Field:   "{{ $fieldName }}",
							Message: message,
							Rule:    "{{ .OriginalExpression }}",
						})
					}
				}
				{{- end }}
				{{- end }}
			}
			{{- else if eq .Type "Required" }}
			// Required validation
			if isFieldEmpty(fieldInterface) {
				errors = append(errors, validation.ValidationError{
					Field:   "{{ $fieldName }}",
					Message: "field is required but empty",
				})
			}
			{{- else if eq .Type "MinLength" }}
			// MinLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) < {{ .Value }} {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("field must be at least {{ .Value }} characters long, got %d", len(str)),
					})
				}
			}
			{{- else if eq .Type "MaxLength" }}
			// MaxLength validation
			if str, ok := fieldInterface.(string); ok {
				if len(str) > {{ .Value }} {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("field must be at most {{ .Value }} characters long, got %d", len(str)),
					})
				}
			}
			{{- else if eq .Type "Minimum" }}
			// Minimum validation
			if num := getNumericValue(fieldInterface); num != nil {
				if *num < {{ .Value }} {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("field must be at least {{ .Value }}, got %v", *num),
					})
				}
			}
			{{- else if eq .Type "Maximum" }}
			// Maximum validation  
			if num := getNumericValue(fieldInterface); num != nil {
				if *num > {{ .Value }} {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("field must be at most {{ .Value }}, got %v", *num),
					})
				}
			}
			{{- else if eq .Type "Pattern" }}
			// Pattern validation
			if str, ok := fieldInterface.(string); ok {
				// Pattern: {{ .Value }}
				if !matchesPattern(str, `{{ .Value }}`) {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: "field does not match required pattern: {{ .Value }}",
					})
				}
			}
			{{- else if eq .Type "Enum" }}
			// Enum validation
			if str, ok := fieldInterface.(string); ok {
				validValues := []string{ {{- $values := split .Value ";" }}{{- range $i, $val := $values }}"{{ $val }}"{{- if lt $i (sub (len $values) 1) }}, {{- end }}{{- end }} }
				isValid := false
				for _, valid := range validValues {
					if str == valid {
						isValid = true
						break
					}
				}
				if !isValid {
					errors = append(errors, validation.ValidationError{
						Field:   "{{ $fieldName }}",
						Message: fmt.Sprintf("field must be one of [%s], got %s", strings.Join(validValues, ", "), str),
					})
				}
			}
			{{- end }}
			{{- end }}
		}
	}
	{{- end }}
	
	return errors
}

func (s *{{ .Kind }}ValidationStrategy) SupportsType(obj runtime.Object) bool {
	// Check if object is of the correct type by examining its ObjectKind
	if objectKind := obj.GetObjectKind(); objectKind != nil {
		gvk := objectKind.GroupVersionKind()
		if gvk.Kind == "{{ .Kind }}" {
			return true
		}
	}
	// Fallback: check by type reflection
	return reflect.TypeOf(obj).String() == "*{{ $.PackageName }}.{{ .Kind }}"
}
{{- end }}
{{- end }}

// Helper functions for validation

// isFieldEmpty checks if a field value is considered empty
func isFieldEmpty(value interface{}) bool {
	if value == nil {
		return true
	}
	
	v := reflect.ValueOf(value)
	switch v.Kind() {
	case reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return false // bool values are never considered empty for required validation
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0.0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
		return v.Len() == 0
	case reflect.Struct:
		// For structs, check if it's a zero value
		return v.Interface() == reflect.Zero(v.Type()).Interface()
	default:
		return false
	}
}

// getNumericValue extracts numeric value from interface{} for numeric validations
func getNumericValue(value interface{}) *float64 {
	if value == nil {
		return nil
	}
	
	v := reflect.ValueOf(value)
	
	// Handle pointers by dereferencing them
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return nil
		}
		v = v.Elem()
	}
	
	var result float64
	
	switch v.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		result = float64(v.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		result = float64(v.Uint())
	case reflect.Float32, reflect.Float64:
		result = v.Float()
	case reflect.String:
		// Try to parse string as number
		if f, err := strconv.ParseFloat(v.String(), 64); err == nil {
			result = f
		} else {
			return nil
		}
	default:
		return nil
	}
	
	return &result
}

// matchesPattern validates string against regex pattern
func matchesPattern(value string, pattern string) bool {
	regex, err := regexp.Compile(pattern)
	if err != nil {
		// If pattern is invalid, consider it as not matching
		return false
	}
	return regex.MatchString(value)
}