
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validation: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dtomasi/k1s/core/pkg/validation/cel.go (74.6%)</option>
				
				<option value="file1">github.com/dtomasi/k1s/core/pkg/validation/field.go (70.0%)</option>
				
				<option value="file2">github.com/dtomasi/k1s/core/pkg/validation/interface.go (0.0%)</option>
				
				<option value="file3">github.com/dtomasi/k1s/core/pkg/validation/validation.go (68.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package validation

import (
        "context"
        "fmt"
        "reflect"
        "sync"

        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "k8s.io/apimachinery/pkg/runtime"
)

// celValidator implements CELValidator interface using google/cel-go library.
type celValidator struct {
        env   *cel.Env
        cache map[string]CompiledCELProgram
        mu    sync.RWMutex
}

// compiledCELProgram implements CompiledCELProgram interface.
type compiledCELProgram struct {
        program    cel.Program
        expression string
}

// NewCELValidator creates a new CEL validator with a standard environment.
func NewCELValidator() CELValidator <span class="cov8" title="1">{
        env, err := cel.NewEnv(
                cel.Variable("self", cel.DynType),
                cel.HomogeneousAggregateLiterals(),
                cel.EagerlyValidateDeclarations(true),
                cel.DefaultUTCTimeZone(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                // This should never happen with our standard configuration
                panic(fmt.Sprintf("failed to create CEL environment: %v", err))</span>
        }

        <span class="cov8" title="1">return &amp;celValidator{
                env:   env,
                cache: make(map[string]CompiledCELProgram),
        }</span>
}

// ValidateCEL evaluates a CEL expression against an object.
func (c *celValidator) ValidateCEL(ctx context.Context, obj runtime.Object, expression string) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot evaluate CEL expression on nil object")
        }</span>
        <span class="cov8" title="1">return c.ValidateCELValue(ctx, obj, expression)</span>
}

// ValidateCELValue evaluates a CEL expression against any value.
func (c *celValidator) ValidateCELValue(ctx context.Context, value interface{}, expression string) error <span class="cov8" title="1">{
        if expression == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("CEL expression cannot be empty")
        }</span>

        // Compile the expression (with caching)
        <span class="cov8" title="1">compiled, err := c.CompileCEL(expression)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compile CEL expression: %w", err)
        }</span>

        // Evaluate the expression
        <span class="cov8" title="1">result, err := compiled.Eval(ctx, value)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("CEL evaluation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if !result </span><span class="cov8" title="1">{
                return fmt.Errorf("CEL expression evaluated to false: %s", expression)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CompileCEL compiles a CEL expression for efficient reuse with caching.
func (c *celValidator) CompileCEL(expression string) (CompiledCELProgram, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("CEL expression cannot be empty")
        }</span>

        // Check cache first
        <span class="cov8" title="1">c.mu.RLock()
        if cached, exists := c.cache[expression]; exists </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                return cached, nil
        }</span>
        <span class="cov8" title="1">c.mu.RUnlock()

        // Compile the expression
        c.mu.Lock()
        defer c.mu.Unlock()

        // Double-check cache after acquiring write lock
        if cached, exists := c.cache[expression]; exists </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // Parse and check the expression
        <span class="cov8" title="1">ast, issues := c.env.Parse(expression)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse CEL expression '%s': %w", expression, issues.Err())
        }</span>

        // Type-check the expression
        <span class="cov8" title="1">checked, issues := c.env.Check(ast)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to type-check CEL expression '%s': %w", expression, issues.Err())
        }</span>

        // Create the program
        <span class="cov8" title="1">program, err := c.env.Program(checked)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create CEL program for '%s': %w", expression, err)
        }</span>

        <span class="cov8" title="1">compiled := &amp;compiledCELProgram{
                program:    program,
                expression: expression,
        }

        // Cache the compiled program
        c.cache[expression] = compiled

        return compiled, nil</span>
}

// Eval executes the compiled CEL expression against a value.
func (p *compiledCELProgram) Eval(ctx context.Context, value interface{}) (bool, error) <span class="cov8" title="1">{
        // Handle nil pointers specially
        if value == nil </span><span class="cov0" title="0">{
                // For nil values, we only support expressions like "self == null"
                vars := map[string]interface{}{
                        "self": nil,
                }
                result, _, err := p.program.Eval(vars)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("evaluation error on nil value: %w", err)
                }</span>
                <span class="cov0" title="0">return p.convertToBool(result)</span>
        }

        // For complex objects or unsupported types, try to convert to CEL-compatible format
        <span class="cov8" title="1">celValue, err := p.convertToValue(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to convert value to CEL format: %w", err)
        }</span>

        // Create evaluation variables
        <span class="cov8" title="1">vars := map[string]interface{}{
                "self": celValue,
        }

        // Execute the program
        result, _, err := p.program.Eval(vars)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("evaluation error: %w", err)
        }</span>

        <span class="cov8" title="1">return p.convertToBool(result)</span>
}

// convertToValue converts Go values to CEL-compatible values
func (p *compiledCELProgram) convertToValue(value interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Handle nil pointers
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Handle pointers by dereferencing them
        <span class="cov8" title="1">if reflect.ValueOf(value).Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(value).Elem().Interface(), nil</span>
        }

        // For most basic types, CEL can handle them directly
        <span class="cov8" title="1">return value, nil</span>
}

// convertToBool converts CEL result to boolean
func (p *compiledCELProgram) convertToBool(result ref.Val) (bool, error) <span class="cov8" title="1">{
        // Convert result to boolean
        if result == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("CEL expression returned nil")
        }</span>

        // Handle CEL boolean values
        <span class="cov8" title="1">if result.Equal(types.True) == types.True </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if result.Equal(types.False) == types.True </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Try to convert to native boolean if possible
        <span class="cov0" title="0">if boolVal, ok := result.(types.Bool); ok </span><span class="cov0" title="0">{
                return bool(boolVal), nil
        }</span>

        <span class="cov0" title="0">return false, fmt.Errorf("CEL expression returned non-boolean result: %T", result)</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package validation

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// fieldValidator implements FieldValidator interface.
type fieldValidator struct {
        manager *manager
}

// NewFieldValidator creates a new field validator.
func NewFieldValidator(mgr ValidationManager) FieldValidator <span class="cov8" title="1">{
        if m, ok := mgr.(*manager); ok </span><span class="cov8" title="1">{
                return &amp;fieldValidator{manager: m}
        }</span>
        // Fallback for interface usage - create a new manager
        <span class="cov0" title="0">newMgr := NewManager()
        if m, ok := newMgr.(*manager); ok </span><span class="cov0" title="0">{
                return &amp;fieldValidator{manager: m}
        }</span>
        // Last resort fallback (should not happen)
        <span class="cov0" title="0">return &amp;fieldValidator{manager: &amp;manager{
                strategies:  make(map[schema.GroupVersionKind][]ValidationStrategy),
                validations: make(map[schema.GroupVersionKind]*ObjectValidation),
        }}</span>
}

// ValidateField validates a specific field in the object.
func (f *fieldValidator) ValidateField(ctx context.Context, obj runtime.Object, fieldPath string) []ValidationError <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return []ValidationError{{
                        Field:   fieldPath,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "cannot validate field on nil object",
                }}
        }</span>

        <span class="cov8" title="1">if fieldPath == "" </span><span class="cov8" title="1">{
                return []ValidationError{{
                        Field:   fieldPath,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "field path cannot be empty",
                }}
        }</span>

        // Get the field value
        <span class="cov0" title="0">fieldValue, err := f.GetFieldValue(obj, fieldPath)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   fieldPath,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("cannot access field: %v", err),
                }}
        }</span>

        // For now, just check if field exists and is accessible
        // In a real implementation, you'd apply specific validation rules for the field
        <span class="cov0" title="0">_ = fieldValue
        return nil</span>
}

// GetFieldValue retrieves the value of a field from an object.
func (f *fieldValidator) GetFieldValue(obj runtime.Object, fieldPath string) (interface{}, error) <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object is nil")
        }</span>

        <span class="cov8" title="1">if fieldPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("field path is empty")
        }</span>

        <span class="cov8" title="1">objValue := reflect.ValueOf(obj)
        if objValue.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                objValue = objValue.Elem()
        }</span>

        <span class="cov8" title="1">return f.getFieldByPath(objValue, fieldPath)</span>
}

// getFieldByPath navigates to a field using a dot-separated path like ".spec.name".
func (f *fieldValidator) getFieldByPath(objValue reflect.Value, fieldPath string) (interface{}, error) <span class="cov8" title="1">{
        // Remove leading dot if present
        if fieldPath[0] == '.' </span><span class="cov8" title="1">{
                fieldPath = fieldPath[1:]
        }</span>

        // Split path into components
        <span class="cov8" title="1">parts := f.splitPath(fieldPath)
        current := objValue

        for _, part := range parts </span><span class="cov8" title="1">{
                if !current.IsValid() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid value encountered in path")
                }</span>

                // Handle pointer types
                <span class="cov8" title="1">if current.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        if current.IsNil() </span><span class="cov0" title="0">{
                                return nil, nil // nil pointer, return nil value
                        }</span>
                        <span class="cov0" title="0">current = current.Elem()</span>
                }

                // Navigate to the field
                <span class="cov8" title="1">if current.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot access field %s on non-struct type %s", part, current.Type())
                }</span>

                <span class="cov8" title="1">field := current.FieldByName(f.capitalizeField(part))
                if !field.IsValid() </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("field %s not found in type %s", part, current.Type())
                }</span>

                <span class="cov8" title="1">current = field</span>
        }

        // Return the interface{} value
        <span class="cov8" title="1">if !current.IsValid() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return current.Interface(), nil</span>
}

// splitPath splits a field path into components.
func (f *fieldValidator) splitPath(path string) []string <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="1">var parts []string
        current := ""

        for _, r := range path </span><span class="cov8" title="1">{
                if r == '.' </span><span class="cov8" title="1">{
                        if current != "" </span><span class="cov8" title="1">{
                                parts = append(parts, current)
                                current = ""
                        }</span>
                } else<span class="cov8" title="1"> {
                        current += string(r)
                }</span>
        }

        <span class="cov8" title="1">if current != "" </span><span class="cov8" title="1">{
                parts = append(parts, current)
        }</span>

        <span class="cov8" title="1">return parts</span>
}

// capitalizeField capitalizes the first letter of a field name for Go struct field access.
func (f *fieldValidator) capitalizeField(field string) string <span class="cov8" title="1">{
        if len(field) == 0 </span><span class="cov0" title="0">{
                return field
        }</span>

        // Capitalize first letter to match Go struct field naming
        <span class="cov8" title="1">return strings.ToUpper(string(field[0])) + field[1:]</span>
}

// basicStrategy is a simple validation strategy for demonstration.
type basicStrategy struct {
        supportedTypes map[reflect.Type]bool
        validateFunc   func(ctx context.Context, obj runtime.Object) []ValidationError
}

// NewBasicStrategy creates a basic validation strategy with a custom function.
func NewBasicStrategy(validateFunc func(ctx context.Context, obj runtime.Object) []ValidationError, supportedTypes ...reflect.Type) ValidationStrategy <span class="cov8" title="1">{
        typeMap := make(map[reflect.Type]bool)
        for _, t := range supportedTypes </span><span class="cov8" title="1">{
                typeMap[t] = true
        }</span>

        <span class="cov8" title="1">return &amp;basicStrategy{
                supportedTypes: typeMap,
                validateFunc:   validateFunc,
        }</span>
}

func (s *basicStrategy) Execute(ctx context.Context, obj runtime.Object) []ValidationError <span class="cov8" title="1">{
        if s.validateFunc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.validateFunc(ctx, obj)</span>
}

func (s *basicStrategy) SupportsType(obj runtime.Object) bool <span class="cov8" title="1">{
        if len(s.supportedTypes) == 0 </span><span class="cov0" title="0">{
                return true // Support all types if none specified
        }</span>

        <span class="cov8" title="1">objType := reflect.TypeOf(obj)
        return s.supportedTypes[objType]</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package validation

import (
        "context"

        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Validator provides the interface for validating objects.
// This interface is compatible with controller-runtime validation patterns.
type Validator interface {
        // Validate validates an object for creation or update.
        Validate(ctx context.Context, obj runtime.Object) error

        // ValidateUpdate validates an object for update, comparing with the old object.
        ValidateUpdate(ctx context.Context, obj, old runtime.Object) error

        // ValidateDelete validates an object for deletion.
        ValidateDelete(ctx context.Context, obj runtime.Object) error
}

// ValidationStrategy defines how to validate objects for a specific type.
// Implementations should be thread-safe as they may be called concurrently.
type ValidationStrategy interface {
        // Execute performs validation on the object and returns validation errors.
        Execute(ctx context.Context, obj runtime.Object) []ValidationError

        // SupportsType returns true if this strategy can handle the given object type.
        SupportsType(obj runtime.Object) bool
}

// ValidationManager coordinates multiple validation strategies and provides
// a unified interface for validating objects.
type ValidationManager interface {
        Validator

        // RegisterStrategy registers a validation strategy for a specific type.
        RegisterStrategy(strategy ValidationStrategy) error

        // UnregisterStrategy removes a validation strategy.
        UnregisterStrategy(strategy ValidationStrategy) error

        // HasValidationFor returns true if validation is configured for the given object type.
        HasValidationFor(obj runtime.Object) bool

        // RegisterObjectValidation registers validation rules for a specific object type.
        RegisterObjectValidation(objValidation *ObjectValidation) error
}

// FieldValidator provides fine-grained validation for individual fields.
type FieldValidator interface {
        // ValidateField validates a specific field in the object.
        // The fieldPath parameter specifies the JSON path to the field.
        ValidateField(ctx context.Context, obj runtime.Object, fieldPath string) []ValidationError

        // GetFieldValue retrieves the value of a field from an object.
        GetFieldValue(obj runtime.Object, fieldPath string) (interface{}, error)
}

// ValidationError represents a validation error with context information.
type ValidationError struct {
        // Field is the JSON path to the field that failed validation
        Field string

        // Value is the invalid value that caused the error
        Value interface{}

        // Type describes the type of validation that failed
        Type ValidationErrorType

        // Message is a human-readable error message
        Message string

        // Rule is the validation rule that was violated (optional)
        Rule string

        // Code is a machine-readable error code (optional)
        Code string
}

// Error implements the error interface.
func (v ValidationError) Error() string <span class="cov0" title="0">{
        if v.Field != "" </span><span class="cov0" title="0">{
                return v.Field + ": " + v.Message
        }</span>
        <span class="cov0" title="0">return v.Message</span>
}

// ValidationErrorType defines the type of validation error.
type ValidationErrorType string

const (
        // ValidationErrorTypeRequired indicates a required field is missing
        ValidationErrorTypeRequired ValidationErrorType = "Required"

        // ValidationErrorTypeInvalid indicates a field has an invalid value
        ValidationErrorTypeInvalid ValidationErrorType = "Invalid"

        // ValidationErrorTypeForbidden indicates a field value is not allowed
        ValidationErrorTypeForbidden ValidationErrorType = "Forbidden"

        // ValidationErrorTypeTooLong indicates a string field is too long
        ValidationErrorTypeTooLong ValidationErrorType = "TooLong"

        // ValidationErrorTypeTooShort indicates a string field is too short
        ValidationErrorTypeTooShort ValidationErrorType = "TooShort"

        // ValidationErrorTypeTooMany indicates an array field has too many items
        ValidationErrorTypeTooMany ValidationErrorType = "TooMany"

        // ValidationErrorTypeTooFew indicates an array field has too few items
        ValidationErrorTypeTooFew ValidationErrorType = "TooFew"

        // ValidationErrorTypeFormat indicates a field has an invalid format
        ValidationErrorTypeFormat ValidationErrorType = "Format"

        // ValidationErrorTypeEnum indicates a field value is not in the allowed enum
        ValidationErrorTypeEnum ValidationErrorType = "Enum"

        // ValidationErrorTypeRange indicates a numeric field is out of range
        ValidationErrorTypeRange ValidationErrorType = "Range"
)

// ValidationRule represents a single validation rule extracted from kubebuilder markers.
type ValidationRule struct {
        // Field is the JSON path to the field (e.g., ".spec.name")
        Field string

        // Type is the type of validation rule
        Type ValidationRuleType

        // Value is the parameter for the validation rule (e.g., "100" for MaxLength)
        Value interface{}

        // Message is a custom error message (optional)
        Message string

        // Condition specifies when this validation should be applied (optional)
        Condition string
}

// ValidationRuleType defines the type of validation rule.
type ValidationRuleType string

const (
        // ValidationRuleTypeRequired indicates a field is required
        ValidationRuleTypeRequired ValidationRuleType = "Required"

        // ValidationRuleTypeMinLength indicates minimum string length
        ValidationRuleTypeMinLength ValidationRuleType = "MinLength"

        // ValidationRuleTypeMaxLength indicates maximum string length
        ValidationRuleTypeMaxLength ValidationRuleType = "MaxLength"

        // ValidationRuleTypeMinimum indicates minimum numeric value
        ValidationRuleTypeMinimum ValidationRuleType = "Minimum"

        // ValidationRuleTypeMaximum indicates maximum numeric value
        ValidationRuleTypeMaximum ValidationRuleType = "Maximum"

        // ValidationRuleTypeEnum indicates allowed values
        ValidationRuleTypeEnum ValidationRuleType = "Enum"

        // ValidationRuleTypePattern indicates regex pattern validation
        ValidationRuleTypePattern ValidationRuleType = "Pattern"

        // ValidationRuleTypeFormat indicates format validation
        ValidationRuleTypeFormat ValidationRuleType = "Format"

        // ValidationRuleTypeCEL indicates CEL expression validation
        ValidationRuleTypeCEL ValidationRuleType = "CEL"

        // ValidationRuleTypeUnique indicates uniqueness validation
        ValidationRuleTypeUnique ValidationRuleType = "Unique"
)

// ObjectValidation contains all validation rules for a specific object type.
type ObjectValidation struct {
        // GVK identifies the object type these validations apply to
        GVK schema.GroupVersionKind

        // Rules is a list of validation rules for this object type
        Rules []ValidationRule

        // OpenAPISchema is the OpenAPI v3 schema for additional validation (optional)
        OpenAPISchema map[string]interface{}
}

// CELValidator provides Common Expression Language (CEL) validation capabilities.
type CELValidator interface {
        // ValidateCEL evaluates a CEL expression against an object
        ValidateCEL(ctx context.Context, obj runtime.Object, expression string) error
        
        // ValidateCELValue evaluates a CEL expression against any value (for testing)
        ValidateCELValue(ctx context.Context, value interface{}, expression string) error

        // CompileCEL compiles a CEL expression for efficient reuse
        CompileCEL(expression string) (CompiledCELProgram, error)
}

// CompiledCELProgram represents a compiled CEL program for efficient execution.
// This replaces CompiledCELExpression for clarity.
type CompiledCELProgram interface {
        // Eval executes the compiled CEL expression against a value
        Eval(ctx context.Context, value interface{}) (bool, error)
}


// ValidationOptions provides configuration options for validation behavior.
type ValidationOptions struct {
        // FailFast stops validation on the first error if true
        FailFast bool

        // IgnoreUnknownFields ignores fields not defined in the schema
        IgnoreUnknownFields bool

        // AllowEmptyObjects allows objects with no required fields set
        AllowEmptyObjects bool

        // MaxErrors limits the number of validation errors returned
        MaxErrors int

        // Strict enables strict validation mode with additional checks
        Strict bool
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package validation

import (
        "context"
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "sync"

        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// manager is the default implementation of ValidationManager.
type manager struct {
        mu          sync.RWMutex
        strategies  map[schema.GroupVersionKind][]ValidationStrategy
        validations map[schema.GroupVersionKind]*ObjectValidation
        options     ValidationOptions
        fieldVal    *fieldValidator
}

// NewManager creates a new validation manager with optional configuration.
func NewManager(opts ...ValidationOption) ValidationManager <span class="cov8" title="1">{
        options := ValidationOptions{
                FailFast:            false,
                IgnoreUnknownFields: false,
                AllowEmptyObjects:   false,
                MaxErrors:           10,
                Strict:              false,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;options)
        }</span>

        <span class="cov8" title="1">mgr := &amp;manager{
                strategies:  make(map[schema.GroupVersionKind][]ValidationStrategy),
                validations: make(map[schema.GroupVersionKind]*ObjectValidation),
                options:     options,
        }

        mgr.fieldVal = &amp;fieldValidator{manager: mgr}
        return mgr</span>
}

// ValidationOption allows for functional configuration of the validation manager.
type ValidationOption func(*ValidationOptions)

// WithFailFast sets the fail-fast option.
func WithFailFast(enabled bool) ValidationOption <span class="cov8" title="1">{
        return func(opts *ValidationOptions) </span><span class="cov8" title="1">{
                opts.FailFast = enabled
        }</span>
}

// WithMaxErrors sets the maximum number of errors to return.
func WithMaxErrors(max int) ValidationOption <span class="cov8" title="1">{
        return func(opts *ValidationOptions) </span><span class="cov8" title="1">{
                opts.MaxErrors = max
        }</span>
}

// WithStrict enables strict validation mode.
func WithStrict(enabled bool) ValidationOption <span class="cov8" title="1">{
        return func(opts *ValidationOptions) </span><span class="cov8" title="1">{
                opts.Strict = enabled
        }</span>
}

// Validate validates an object for creation or update.
func (m *manager) Validate(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot validate nil object")
        }</span>

        <span class="cov8" title="1">errors := m.validateObject(ctx, obj, nil)
        if len(errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Convert to error
        <span class="cov8" title="1">return &amp;ValidationErrors{Errors: errors}</span>
}

// ValidateUpdate validates an object for update, comparing with the old object.
func (m *manager) ValidateUpdate(ctx context.Context, obj, old runtime.Object) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot validate nil object")
        }</span>

        <span class="cov8" title="1">errors := m.validateObject(ctx, obj, old)
        if len(errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;ValidationErrors{Errors: errors}</span>
}

// ValidateDelete validates an object for deletion.
func (m *manager) ValidateDelete(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot validate nil object")
        }</span>

        // For deletion, we mainly check if the object can be safely deleted
        // This is typically handled by finalizers and admission controllers
        // but we can add custom deletion validation here
        <span class="cov8" title="1">return nil</span>
}

// validateObject performs the actual validation logic.
func (m *manager) validateObject(ctx context.Context, obj runtime.Object, _ runtime.Object) []ValidationError <span class="cov8" title="1">{
        var allErrors []ValidationError

        gvk := obj.GetObjectKind().GroupVersionKind()
        if gvk.Empty() </span><span class="cov0" title="0">{
                gvk = m.inferGVK(obj)
        }</span>

        <span class="cov8" title="1">m.mu.RLock()
        strategies := m.strategies[gvk]
        allStrategies := m.strategies[schema.GroupVersionKind{Group: "*", Version: "*", Kind: "*"}]
        objValidation := m.validations[gvk]
        m.mu.RUnlock()

        // Apply GVK-specific strategy-based validation
        for _, strategy := range strategies </span><span class="cov0" title="0">{
                if strategy.SupportsType(obj) </span><span class="cov0" title="0">{
                        errors := strategy.Execute(ctx, obj)
                        allErrors = append(allErrors, errors...)

                        if m.options.FailFast &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                                return allErrors
                        }</span>
                }
        }

        // Apply global strategy-based validation
        <span class="cov8" title="1">for _, strategy := range allStrategies </span><span class="cov8" title="1">{
                if strategy.SupportsType(obj) </span><span class="cov8" title="1">{
                        errors := strategy.Execute(ctx, obj)
                        allErrors = append(allErrors, errors...)

                        if m.options.FailFast &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                                return allErrors
                        }</span>
                }
        }

        // Apply kubebuilder marker-based validation
        <span class="cov8" title="1">if objValidation != nil </span><span class="cov8" title="1">{
                errors := m.applyObjectValidation(ctx, obj, objValidation)
                allErrors = append(allErrors, errors...)
        }</span>

        // Limit number of errors if configured
        <span class="cov8" title="1">if m.options.MaxErrors &gt; 0 &amp;&amp; len(allErrors) &gt; m.options.MaxErrors </span><span class="cov8" title="1">{
                allErrors = allErrors[:m.options.MaxErrors]
        }</span>

        <span class="cov8" title="1">return allErrors</span>
}

// RegisterStrategy registers a validation strategy for objects.
func (m *manager) RegisterStrategy(strategy ValidationStrategy) error <span class="cov8" title="1">{
        if strategy == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("strategy cannot be nil")
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        // Register strategy globally for now - could be enhanced to be GVK-specific
        allGVK := schema.GroupVersionKind{Group: "*", Version: "*", Kind: "*"}
        m.strategies[allGVK] = append(m.strategies[allGVK], strategy)

        return nil</span>
}

// UnregisterStrategy removes a validation strategy.
func (m *manager) UnregisterStrategy(strategy ValidationStrategy) error <span class="cov8" title="1">{
        if strategy == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("strategy cannot be nil")
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        // Remove from all GVK entries
        for gvk, strategies := range m.strategies </span><span class="cov8" title="1">{
                for i, s := range strategies </span><span class="cov8" title="1">{
                        if s == strategy </span><span class="cov8" title="1">{
                                // Remove strategy from slice
                                m.strategies[gvk] = append(strategies[:i], strategies[i+1:]...)
                                break</span>
                        }
                }
                // Clean up empty slices
                <span class="cov8" title="1">if len(m.strategies[gvk]) == 0 </span><span class="cov8" title="1">{
                        delete(m.strategies, gvk)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// HasValidationFor returns true if validation is configured for the given object type.
func (m *manager) HasValidationFor(obj runtime.Object) bool <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">gvk := obj.GetObjectKind().GroupVersionKind()
        if gvk.Empty() </span><span class="cov8" title="1">{
                gvk = m.inferGVK(obj)
        }</span>

        <span class="cov8" title="1">m.mu.RLock()
        defer m.mu.RUnlock()

        // Check for GVK-specific strategies
        if strategies, exists := m.strategies[gvk]; exists &amp;&amp; len(strategies) &gt; 0 </span><span class="cov0" title="0">{
                for _, strategy := range strategies </span><span class="cov0" title="0">{
                        if strategy.SupportsType(obj) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // Check for global strategies
        <span class="cov8" title="1">allGVK := schema.GroupVersionKind{Group: "*", Version: "*", Kind: "*"}
        if strategies, exists := m.strategies[allGVK]; exists &amp;&amp; len(strategies) &gt; 0 </span><span class="cov8" title="1">{
                for _, strategy := range strategies </span><span class="cov8" title="1">{
                        if strategy.SupportsType(obj) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        // Check for object validation rules
        <span class="cov8" title="1">_, hasValidation := m.validations[gvk]
        return hasValidation</span>
}

// RegisterObjectValidation registers validation rules for a specific object type.
func (m *manager) RegisterObjectValidation(objValidation *ObjectValidation) error <span class="cov8" title="1">{
        if objValidation == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("object validation cannot be nil")
        }</span>

        <span class="cov8" title="1">if objValidation.GVK.Empty() </span><span class="cov8" title="1">{
                return fmt.Errorf("object validation must specify a valid GVK")
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        m.validations[objValidation.GVK] = objValidation
        return nil</span>
}

// applyObjectValidation applies the validation rules defined in ObjectValidation.
func (m *manager) applyObjectValidation(_ context.Context, obj runtime.Object, objValidation *ObjectValidation) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        for _, rule := range objValidation.Rules </span><span class="cov8" title="1">{
                ruleErrors := m.applyValidationRule(obj, rule)
                errors = append(errors, ruleErrors...)

                if m.options.FailFast &amp;&amp; len(ruleErrors) &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// applyValidationRule applies a single validation rule to the object.
func (m *manager) applyValidationRule(obj runtime.Object, rule ValidationRule) []ValidationError <span class="cov8" title="1">{
        // Get the field value
        fieldValue, err := m.fieldVal.GetFieldValue(obj, rule.Field)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   rule.Field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("cannot access field: %v", err),
                }}
        }</span>

        <span class="cov8" title="1">switch rule.Type </span>{
        case ValidationRuleTypeRequired:<span class="cov8" title="1">
                return m.validateRequired(rule.Field, fieldValue, rule.Message)</span>
        case ValidationRuleTypeMinLength:<span class="cov8" title="1">
                return m.validateMinLength(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        case ValidationRuleTypeMaxLength:<span class="cov8" title="1">
                return m.validateMaxLength(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        case ValidationRuleTypeMinimum:<span class="cov8" title="1">
                return m.validateMinimum(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        case ValidationRuleTypeMaximum:<span class="cov0" title="0">
                return m.validateMaximum(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        case ValidationRuleTypeEnum:<span class="cov8" title="1">
                return m.validateEnum(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        case ValidationRuleTypePattern:<span class="cov0" title="0">
                return m.validatePattern(rule.Field, fieldValue, rule.Value, rule.Message)</span>
        default:<span class="cov0" title="0">
                return []ValidationError{{
                        Field:   rule.Field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("unsupported validation rule type: %s", rule.Type),
                }}</span>
        }
}

// Validation rule implementations

func (m *manager) validateRequired(field string, value interface{}, customMessage string) []ValidationError <span class="cov8" title="1">{
        if m.isZeroValue(value) </span><span class="cov8" title="1">{
                message := customMessage
                if message == "" </span><span class="cov8" title="1">{
                        message = "field is required"
                }</span>
                <span class="cov8" title="1">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeRequired,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *manager) validateMinLength(field string, value interface{}, minLen interface{}, customMessage string) []ValidationError <span class="cov8" title="1">{
        str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return nil // nil values are handled by required validation
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "value must be a string",
                        Value:   value,
                }}</span>
        }

        <span class="cov8" title="1">min, err := m.parseIntValue(minLen)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("invalid min length parameter: %v", err),
                }}
        }</span>

        <span class="cov8" title="1">if len(str) &lt; min </span><span class="cov8" title="1">{
                message := customMessage
                if message == "" </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("string must be at least %d characters long", min)
                }</span>
                <span class="cov8" title="1">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeTooShort,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *manager) validateMaxLength(field string, value interface{}, maxLen interface{}, customMessage string) []ValidationError <span class="cov8" title="1">{
        str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return nil // nil values are handled by required validation
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "value must be a string",
                        Value:   value,
                }}</span>
        }

        <span class="cov8" title="1">max, err := m.parseIntValue(maxLen)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("invalid max length parameter: %v", err),
                }}
        }</span>

        <span class="cov8" title="1">if len(str) &gt; max </span><span class="cov8" title="1">{
                message := customMessage
                if message == "" </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("string must be at most %d characters long", max)
                }</span>
                <span class="cov8" title="1">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeTooLong,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *manager) validateMinimum(field string, value interface{}, minVal interface{}, customMessage string) []ValidationError <span class="cov8" title="1">{
        num, err := m.parseNumericValue(value)
        if err != nil </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return nil // nil values are handled by required validation
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("value must be numeric: %v", err),
                        Value:   value,
                }}</span>
        }

        <span class="cov8" title="1">min, err := m.parseNumericValue(minVal)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("invalid minimum parameter: %v", err),
                }}
        }</span>

        <span class="cov8" title="1">if num &lt; min </span><span class="cov8" title="1">{
                message := customMessage
                if message == "" </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("value must be at least %v", minVal)
                }</span>
                <span class="cov8" title="1">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeRange,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *manager) validateMaximum(field string, value interface{}, maxVal interface{}, customMessage string) []ValidationError <span class="cov0" title="0">{
        num, err := m.parseNumericValue(value)
        if err != nil </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return nil // nil values are handled by required validation
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("value must be numeric: %v", err),
                        Value:   value,
                }}</span>
        }

        <span class="cov0" title="0">max, err := m.parseNumericValue(maxVal)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("invalid maximum parameter: %v", err),
                }}
        }</span>

        <span class="cov0" title="0">if num &gt; max </span><span class="cov0" title="0">{
                message := customMessage
                if message == "" </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("value must be at most %v", maxVal)
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeRange,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *manager) validateEnum(field string, value interface{}, enumVal interface{}, customMessage string) []ValidationError <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil // nil values are handled by required validation
        }</span>

        // Parse enum values - expect semicolon-separated string
        <span class="cov8" title="1">enumStr, ok := enumVal.(string)
        if !ok </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "enum parameter must be a string",
                }}
        }</span>

        <span class="cov8" title="1">allowedValues := strings.Split(enumStr, ";")
        valueStr := fmt.Sprintf("%v", value)

        for _, allowed := range allowedValues </span><span class="cov8" title="1">{
                if strings.TrimSpace(allowed) == valueStr </span><span class="cov8" title="1">{
                        return nil // Valid enum value
                }</span>
        }

        <span class="cov8" title="1">message := customMessage
        if message == "" </span><span class="cov8" title="1">{
                message = fmt.Sprintf("value must be one of: %s", enumStr)
        }</span>
        <span class="cov8" title="1">return []ValidationError{{
                Field:   field,
                Type:    ValidationErrorTypeEnum,
                Message: message,
                Value:   value,
        }}</span>
}

func (m *manager) validatePattern(field string, value interface{}, pattern interface{}, customMessage string) []ValidationError <span class="cov0" title="0">{
        str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return nil // nil values are handled by required validation
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "value must be a string for pattern validation",
                        Value:   value,
                }}</span>
        }

        <span class="cov0" title="0">patternStr, ok := pattern.(string)
        if !ok </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: "pattern parameter must be a string",
                }}
        }</span>

        <span class="cov0" title="0">regex, err := regexp.Compile(patternStr)
        if err != nil </span><span class="cov0" title="0">{
                return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeInvalid,
                        Message: fmt.Sprintf("invalid regex pattern: %v", err),
                }}
        }</span>

        <span class="cov0" title="0">if !regex.MatchString(str) </span><span class="cov0" title="0">{
                message := customMessage
                if message == "" </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("value does not match pattern: %s", patternStr)
                }</span>
                <span class="cov0" title="0">return []ValidationError{{
                        Field:   field,
                        Type:    ValidationErrorTypeFormat,
                        Message: message,
                        Value:   value,
                }}</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (m *manager) isZeroValue(value interface{}) bool <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(value)
        switch v.Kind() </span>{
        case reflect.Ptr, reflect.Slice, reflect.Map, reflect.Chan, reflect.Func, reflect.Interface:<span class="cov0" title="0">
                return v.IsNil()</span>
        default:<span class="cov8" title="1">
                zero := reflect.Zero(v.Type())
                return reflect.DeepEqual(value, zero.Interface())</span>
        }
}

func (m *manager) parseIntValue(value interface{}) (int, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return v, nil</span>
        case int32:<span class="cov0" title="0">
                return int(v), nil</span>
        case int64:<span class="cov0" title="0">
                return int(v), nil</span>
        case string:<span class="cov0" title="0">
                return strconv.Atoi(v)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to int", value)</span>
        }
}

func (m *manager) parseNumericValue(value interface{}) (float64, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int32:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseFloat(v, 64)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to numeric value", value)</span>
        }
}

func (m *manager) inferGVK(obj runtime.Object) schema.GroupVersionKind <span class="cov8" title="1">{
        objType := reflect.TypeOf(obj)
        if objType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                objType = objType.Elem()
        }</span>

        // Extract package and type name to construct GVK
        <span class="cov8" title="1">pkg := objType.PkgPath()
        name := objType.Name()

        var group, version string
        if pkg != "" &amp;&amp; name != "" </span><span class="cov8" title="1">{
                if len(pkg) &gt; 0 </span><span class="cov8" title="1">{
                        parts := strings.Split(pkg, "/")
                        if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                                version = parts[len(parts)-1] // Last part is version
                                group = "inventory.k1s.io"    // Hardcoded for our examples
                        }</span>
                }
        }

        <span class="cov8" title="1">return schema.GroupVersionKind{
                Group:   group,
                Version: version,
                Kind:    name,
        }</span>
}

// ValidationErrors aggregates multiple validation errors.
type ValidationErrors struct {
        Errors []ValidationError
}

func (v *ValidationErrors) Error() string <span class="cov0" title="0">{
        if len(v.Errors) == 0 </span><span class="cov0" title="0">{
                return "validation failed"
        }</span>

        <span class="cov0" title="0">if len(v.Errors) == 1 </span><span class="cov0" title="0">{
                return v.Errors[0].Error()
        }</span>

        <span class="cov0" title="0">var messages []string
        for _, err := range v.Errors </span><span class="cov0" title="0">{
                messages = append(messages, err.Error())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("validation failed: %s", strings.Join(messages, "; "))</span>
}

// IsValidationError checks if an error is a validation error.
func IsValidationError(err error) bool <span class="cov8" title="1">{
        _, ok := err.(*ValidationErrors)
        return ok
}</span>

// GetValidationErrors extracts validation errors from an error.
func GetValidationErrors(err error) []ValidationError <span class="cov8" title="1">{
        if verr, ok := err.(*ValidationErrors); ok </span><span class="cov8" title="1">{
                return verr.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
